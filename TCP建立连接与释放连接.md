# TCP建立连接与释放连接
![](https://user-gold-cdn.xitu.io/2019/7/30/16c411c7910ab270?w=3120&h=4160&f=jpeg&s=2727919)
**三次握手建立连接的过程**：<br>
①客户A主动打开连接，并向B发送一个连接请求报文，报文首部中的同步位SYN＝1，并且选择一个初始序号seq＝x（TCP规定，SYN＝1的报文段不能携带数据，但要消耗一个序号）。<br>
②服务器B收到请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中SYN和ACK都置为1，确认号是ack=x+1，同时也为自己选择一个初始序号seq=y（这个报文段也不能携带数据，但同样要消耗掉一个序号）。<br>
③客户A收到服务器B的确认后，还要向B给出确认。确认报文段的ACK置为1，确认号ack=y+1，而自己的序号seq=x+1（TCP规定，ACK报文段可以携带数据，但如果不携带数据则不消耗序号；因此，下一个数据报文段的序号仍然是seq=x+1）。此时，服务器B打开连接。<br>
**为什么TCP建立连接是三次握手，而不是两次握手？即为什么A最后还要发送一次确认呢？**<br>
答：因为若A最后不在发送确认，那么存在一种情况会导致服务器B的资源被白白浪费。<br>
例如：客户A发送一个连接请求报文，但是因为网络状况不好的原因，在网络中的某些网络结点长时间逗留了（因为报文超时还未到达B，于是A重新发送了一个连接请求报文），以至于延误到释放连接后的某个时间才到达B。本来这是已经失效的报文，但是B收到此连接请求报文后，以为是A又发送出来的一次新的连接请求。于是就向A发送了确认报文，同意建立连接（若不采用报文握手，只要B发送确认，新的连接就建立了）。
由于A没有发送连接请求报文，因此根本不会理睬B的确认，也不会向B发送数据。但B却以为连接已经建立了，一直在等待A发送来数据。于是，B的许多资源就会被白白浪费了。<br>




![](https://user-gold-cdn.xitu.io/2019/7/30/16c411cbf862069b?w=3120&h=4160&f=jpeg&s=2690169)
**四次挥手释放连接的过程：**<br>
①客户A的应用进程先向其TCP发送连接释放报文段，并停止发送数据，主动关闭TCP连接（只是A不能发送数据了，连接还未释放）。客户A把连接释放报文段首部的终止控制位FIN置为1，其序号seq=u（它的值等于前面已传送过的数据的最后一个字节的序号加1），（TCP规定，FIN报文段即使不携带数据，它也要消耗掉一个序号）。<br>
②服务器B收到连接释放报文段后即发出确认，ACK=1，确认号是ack=u+1，序号=v（它的值等于B前面已传送过的数据的最后一个字节的序号加1）。TCP服务器进程这时通知高层应用进程，因而从A到B这个方向的连接就释放了。（B无法在接收数据）<br>
③若服务器B已经没有要向A发送的数据了，其应用进程就通知TCP释放连接。此时，B发出连接释放报文段，首部中FIN=1，序号=w（在半关闭状态B可能又发送了一些数据），ACK=1，确认号ack=u+1（之前第二步时，ACK报文段没有携带数据，因此不消耗序号）。<br>
④客户A在收到B的连接释放报文段后，对此发出确认。在确认报文段的首部中，ACK=1，seq=u+1（因为第一步中的FIN报文段即使不携带数据，它也要消耗掉一个序号），确认号ack=w+1.。此时B已经关闭了连接（只是B已经无法发送数据，连接还未释放）。<br>
经过时间等待计时器设置的时间2MSL（MSL为最长报文段寿命）后，A才进入关闭状态（此时A无法在接收数据）。此时从B到A方向的连接释放。<br>
