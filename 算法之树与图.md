* 树、二叉树、二叉搜索树
    * 二叉搜索树也称有序二叉树、排序二叉树，是指一颗空树或者具有下列性质的二叉树：
        * 左子树上所有结点的值均小于它的根结点的值
        * 右子树上所有结点的值均大于它的根结点的值
        * 依次类推，左右子树也分别为二叉搜索树。
* 图

练习：<br>
1、验证二叉搜索树

链接：https://leetcode-cn.com/problems/validate-binary-search-tree

题目描述：
```java
/**
 * 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
	
	假设一个二叉搜索树具有如下特征：
	
	节点的左子树只包含小于当前节点的数。
	节点的右子树只包含大于当前节点的数。
	所有左子树和右子树自身必须也是二叉搜索树。
	示例 1:
	
	输入:
	    2
	   / \
	  1   3
	输出: true
	示例 2:
	
	输入:
	    5
	   / \
	  1   4
	     / \
	    3   6
	输出: false
	解释: 输入为: [5,1,4,null,null,3,6]。
	     根节点的值为 5 ，但是其右子节点值为 4 。
	
	来源：力扣（LeetCode）
	链接：https://leetcode-cn.com/problems/validate-binary-search-tree
	著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * @author admin
 *
 */
```
解题代码:
```java
package com.pdsu.leedcode.treeandgraph;

import java.util.LinkedList;
import java.util.Stack;

public class Leedcode98 {
	public static void main(String[] args) {
		TreeNode bst=new TreeNode(5);
		TreeNode node=new TreeNode(4);
		bst.left=new TreeNode(1);
		bst.right=node;
		node.left=new TreeNode(3);		
		node.right=new TreeNode(6);
		Leedcode98 lc=new Leedcode98();
		boolean validBST = lc.isValidBST(bst);
		System.out.println(validBST);
	}
	/*
	 * 	方法一：递归（最优解）
	 * 	递归比较左子树小于根结点，右子树大于根结点
	 */
	public boolean helper(TreeNode node,Integer lower,Integer upper) {
		//空树也是二叉搜索树
		if(node==null) 
			return true;
		//获得当前节点的值
		int val=node.val;
		//若根结点小于左子树，则不是二叉搜索树
		if(lower!=null && val<=lower)
			return false;
		//若根结点大于右子树，则不是二叉搜索树
		if(upper!=null && val>=upper)
			return false;
		//递归遍历右子树
		if(!helper(node.right,val,upper))
			return false;
		//递归遍历左子树
		if(!helper(node.left,lower,val))
			return false;
		return true;
	}
	public boolean isValidBST(TreeNode root) {
        return helper(root,null,null);
    }
	/*
	 * 	方法二：中序遍历
	 * 	遍历的结果为升序，则是二叉搜索树
	 */
	public boolean isValidBST1(TreeNode root) {
		Stack<TreeNode> stack=new Stack<>();
		//初始化该值为非常小的值
		double inorder=-Double.MAX_VALUE;
		while(!stack.isEmpty()|| root!=null) {
			//首先遍历左子树
			while(root!=null) {
				stack.push(root);
				root=root.left;
			}
			//左子树遍历到底，从栈中取出栈顶元素（当前节点的根或右子树根结点）
			root=stack.pop();
			if(root.val<=inorder)
				return false;
			//更新该值
			inorder=root.val;
			//左子树遍历完后，开始遍历右子树
			root=root.right;
		}
		return true;
    }
	/*
	 * 	方法三：迭代法（上述递归法的转化），使用深度优先搜索
	 */
	LinkedList<TreeNode> stack=new LinkedList<>();
	LinkedList<Integer> lowers=new LinkedList<>();
	LinkedList<Integer> uppers=new LinkedList<>();
	
	public void update(TreeNode root,Integer lower,Integer upper) {
		stack.add(root);
		lowers.add(lower);
		uppers.add(upper);
	}
	
	public boolean isValidBST2(TreeNode root) {
		Integer lower=null,upper=null,val;
		//初始化队列
		update(root,lower,upper);
		while(!stack.isEmpty()) {
			//元素出队
			root=stack.poll();
			lower=lowers.poll();
			upper=uppers.poll();
			if(root==null)
				continue;
			val=root.val;
			//将节点与左右子树值进行比较
			if(lower!=null && val<=lower) return false;
			if(upper!=null && val>=upper) return false;
			//迭代，将下一次需要进行比较的元素入队
			update(root.right,val,upper);
			update(root.left,lower,val);
		}
		return true;
	}
}
class TreeNode {
	 int val;
	 TreeNode left;
	 TreeNode right;
	 TreeNode(int x) { val = x; }
}

```
2、二叉树的最近公共祖先

链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree

题目描述：
```java
/**
 * 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
	
	百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
	
	例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]
	
	
	
	 
	
	示例 1:
	
	输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
	输出: 3
	解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
	示例 2:
	
	输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
	输出: 5
	解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
	 
	
	说明:
	
	所有节点的值都是唯一的。
	p、q 为不同节点且均存在于给定的二叉树中。
	
	来源：力扣（LeetCode）
	链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree
	著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * @author admin
 *
 */
```
解题代码：
```java
package com.pdsu.leedcode.treeandgraph;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class Leedcode236 {
	public static void main(String[] args) {
		
	}
	/*
	 * 方法一：递归
	 */
	//保存最近公共祖先节点
	private TreeNode ans=null;
	
	private boolean recurseTree(TreeNode currentNode, TreeNode p, TreeNode q) {
		//若当前节点为空，则无需在找左右子树
		if(currentNode==null) {
			return false;
		}
		//记录左子树中是否有找到p或q其中一个节点
		int left=this.recurseTree(currentNode.left, p, q)?1:0;
		//记录右子树中是否有找到p或q其中一个节点
		int right=this.recurseTree(currentNode.right, p, q)?1:0;
		//记录当前节点是否为q或p其中一个节点
		int mid=(currentNode==p || currentNode==q)?1:0;
		//若三者之和大于等于2，则代表当前节点为q和p的最近公共祖先节点
		if(left+right+mid>=2) {
			this.ans=currentNode;
		}
		//若三者之和大于0，则代表找到了最近公共祖先节点
		return (left+right+mid>0);
	}
	public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
		//调用递归函数
        this.recurseTree(root, p, q);
        //递归遍历完后，返回结果
        return this.ans;
    }
	
	/*
	 * 方法二:使用父指针迭代
	 */
	public TreeNode lowestCommonAncestor1(TreeNode root, TreeNode p, TreeNode q) {
		//保存二叉树中的所有节点
		Deque<TreeNode> stack=new ArrayDeque<>();
		//保存父指针
		Map<TreeNode,TreeNode> parent=new HashMap<>();
		//初始化父指针哈希表
		parent.put(root, null);
		stack.push(root);
		//遍历二叉树，直至找到p或q（parent集合中保存了p和q的所有祖先节点）
		while(!parent.containsKey(p) || !parent.containsKey(q)) {
			//获取当前节点
			TreeNode node=stack.pop();
			//遍历左子树
			if(node.left!=null) {
				//更新父指针集合
				parent.put(node.left, node);
				//保存当前节点的左节点
				stack.push(node.left);
			}
			//遍历右子树
			if(node.right!=null) {
				//更新父指针集合
				parent.put(node.right, node);
				//保存当前节点的右节点
				stack.push(node.right);
			}
		}
		//用于保存祖先节点
		Set<TreeNode> ancestors=new HashSet<>();
		//获取p节点的所有祖先节点
		while(p!=null) {
			//将p节点添加到集合中
			ancestors.add(p);
			//更新p节点为当前p的父亲节点
			p=parent.get(p);
		}
		//寻找p和q的最近祖先节点
		while(!ancestors.contains(q)) {
			//若当前节点不在ancestors集合中，将当前节点更新为其父节点
			q=parent.get(q);
		}
		//经过之前的遍历，q节点保存的为q和p两个节点的最近祖先节点
		return q;
	}
}

```
3、二叉搜索树的最近公共祖先

链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree

题目描述：
```java
/**
 * 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
	
	百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
	
	例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
	
	
	
	 
	
	示例 1:
	
	输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
	输出: 6 
	解释: 节点 2 和节点 8 的最近公共祖先是 6。
	示例 2:
	
	输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
	输出: 2
	解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
	 
	
	说明:
	
	所有节点的值都是唯一的。
	p、q 为不同节点且均存在于给定的二叉搜索树中。
	
	来源：力扣（LeetCode）
	链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree
	著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * @author admin
 *
 */
```
解题代码：
```java
package com.pdsu.leedcode.treeandgraph;

public class Leedcode235 {
	/*
	 * 方法一：递归（最优解）
	 */
	public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
		//当p和q的值都小于root的值时，只需要找左子树即可
        if(p.val<root.val && q.val<root.val) {
        	return lowestCommonAncestor(root.left, p, q);
        }
        //当p和q的值都大于root的值时，只需要找右子树即可
        if(p.val>root.val && q.val>root.val) {
        	return lowestCommonAncestor(root.right, p, q);
        }
        //当p和q分别位于root两端时，root就是其最近公共祖先节点
        return root;
    }
	/*
	 * 方法二：迭代
	 */
	public TreeNode lowestCommonAncestor1(TreeNode root, TreeNode p, TreeNode q) {
		//遍历二叉搜索树
		while(root!=null) {
			//当p和q的值都小于root的值时，只需要找左子树即可
			if(p.val<root.val && q.val<root.val) {
				root=root.left;
				//当p和q的值都大于root的值时，只需要找右子树即可
			}else if(p.val>root.val && q.val>root.val) {
				root=root.right;
			}else
				//当p和q分别位于root两端时，root就是其最近公共祖先节点
				return root;
		}
		//若没有找到，直接返回空
		return null;
	}
}

```

* 二叉树的遍历
    * 前序遍历（Pre-order）
        * 根-左-右
    * 中序遍历（In-order）
        * 左-根-右
    * 后序遍历（Post-order）
        * 左-右-根
        
代码实现：

1、前序遍历 

1）递归实现： 
```java
public void preOrderTraverse1(TreeNode root) {
    if (root != null) {
        System.out.print(root.val + "->");
        preOrderTraverse1(root.left);
        preOrderTraverse1(root.right);
    }
}
```
2）非递归实现：
```java
public void preOrderTraverse2(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    TreeNode node = root;
    while (node != null || !stack.empty()) {
        if (node != null) {
            System.out.print(node.val + "->");
            stack.push(node);
            node = node.left;
        } else {
            TreeNode tem = stack.pop();
            node = tem.right;
        }
    }
}
```
2、中序遍历

1）、递归实现
```java
public void inOrderTraverse(TreeNode root) {
    if (root != null) {
        inOrderTraverse(root.left);
        System.out.print(root.val + "->");
        inOrderTraverse(root.right);
    }
}
```
2)、非递归实现
```java
public void inOrderTraverse(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    TreeNode node = root;
    while (node != null || !stack.isEmpty()) {
        if (node != null) {
            stack.push(node);
            node = node.left;
        } else {
            TreeNode tem = stack.pop();
            System.out.print(tem.val + "->");
            node = tem.right;
        }
    }
}
```
3、后序遍历

1）、递归实现
```java
public void postOrderTraverse(TreeNode root) {
    if (root != null) {
        postOrderTraverse(root.left);
        postOrderTraverse(root.right);
        System.out.print(root.val + "->");
    }
}
```
2）、非递归实现
```java
public void postOrderTraverse(TreeNode root) {
    TreeNode cur, pre = null;

    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);

    while (!stack.empty()) {
        cur = stack.peek();
        if ((cur.left == null && cur.right == null) || (pre != null && (pre == cur.left || pre == cur.right))) {
            System.out.print(cur.val + "->");
            stack.pop();
            pre = cur;
        } else {
            if (cur.right != null)
                stack.push(cur.right);
            if (cur.left != null)
                stack.push(cur.left);
        }
    }
}
```
4、层次遍历
```java
public void levelOrderTraverse(TreeNode root) {
    if (root == null) {
        return;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);

    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        System.out.print(node.val + "->");

        if (node.left != null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
    }
}
```

    
