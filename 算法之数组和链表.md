数组：
* 时间复杂度（平均）：
    * 查询：O(1)
    * 插入：O(n)
    * 删除：O(n)

链表：
* 时间复杂度（平均）：
    * 单链表：
        * 查询：O(n)
        * 插入：O(1)
        * 删除：O(1)
    * 双链表：
        * 查询：O(n)
        * 插入：O(1)
        * 删除：O(1)

练习：<br>
1、反转单链表<br>

链接：https://leetcode-cn.com/problems/reverse-linked-list

题目描述：
```java
/**
 * 反转一个单链表。
	
	示例:
	
	输入: 1->2->3->4->5->NULL
	输出: 5->4->3->2->1->NULL
	进阶:
	你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
	
	来源：力扣（LeetCode）
	链接：https://leetcode-cn.com/problems/reverse-linked-list
 * @author admin
 *
 */
```
解题代码：<br>
```java
package com.pdsu.leedcode;

import java.util.Scanner;

public class Leedcode206 {
	public static void main(String[] args) {
		Scanner scan=new Scanner(System.in);
		String in=scan.next();
		String[] split = in.split("->");
		int[] vals=new int[split.length-1];
		for(int i=0;i<split.length-1;i++) {
			vals[i]=Integer.parseInt(split[i]);
		}
		Leedcode206 lc=new Leedcode206();
		if(vals.length>0) {
			ListNode head=new ListNode(vals[0]);
			for(int i=1;i<vals.length;i++) {
				lc.addList(vals[i], head);
			}
			ListNode reverseList = lc.reverseList(head);
			lc.selectList(reverseList);
		}
	}
	/**反转单链表
	 * 方法一:迭代
	 * @param head
	 * @return
	 */
	public ListNode reverseList(ListNode head) {
		//若链表中只有一个节点或没有节点直接返回head即可
		if(head==null || head.next==null) {
			return head;
		}
		//结果
		ListNode pre=null;
		ListNode cur=head;
		while(cur!=null) {
			//保存当前节点
			ListNode temp=cur;
			//指向下一节点
			cur=cur.next;
			//临时保存反转后的链表
			temp.next=pre;
			//获得反转后的链表
			pre=temp;
		}
		//返回结果
		return pre;
	}
	/**
	 * 方法二:递归
	 * @param head
	 * @return
	 */
	public ListNode reverseList1(ListNode head) {
		//若链表中只有一个节点或没有节点直接返回head即可
		if(head==null || head.next==null) {
			return head;
		}
		/*
		 * 例:1->2->3->null
		 * 
		 * reverseList1(3)----3
		 * reverseList1(2)
		 * 	p=3
		 * 	3.next=2
		 * 	2.next=null
		 * 	return 3->2->null
		 * reverseList1(1)
		 * 	p=3->2->null
		 * 	2.next=1
		 * 	1.next=null
		 * 	return 3->2->1->null
		 */
		ListNode p=reverseList1(head.next);
		head.next.next=head;
		head.next=null;
		return p;
	}
	//单链表添加节点
	public void addList(int val,ListNode head) {
		//临时节点，存储值
		ListNode node = new ListNode(val);
		ListNode temp=head;
		//遍历到最后一个节点
		while(temp.next!=null) {
			temp=temp.next;
		}
		//最后一个节点的下一个节点为临时节点
		temp.next=node;
		//保存增加后的链表
		head=temp;
	}
	//遍历单链表
	public void selectList(ListNode node) {
		while(true) {
			if(node!=null) {
				System.out.print(node.val+"->");
				node=node.next;
			}
			else
				break;
		}
		System.out.print("NULL");
	}
}
//单链表结构
class ListNode {
	 int val;
	 ListNode next;
	 ListNode(int x) { val = x; }
}

```

2、两两交换链表中的节点

链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs

题目描述：<br>
```java
/**
 * 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

	你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
	
	 
	示例:
	
	给定 1->2->3->4, 你应该返回 2->1->4->3.
	
	来源：力扣（LeetCode）
	链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs
	著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * @author admin
 *
 */
```
解题代码：
```java
package com.pdsu.leedcode;

import java.util.Scanner;

public class Leedcode24 {
	public static void main(String[] args) {
		Scanner scan=new Scanner(System.in);
		String str=scan.next();
		String[] split = str.split("->");
		int[] vals=new int[split.length];
		for(int i=0;i<split.length;i++) {
			vals[i]=Integer.parseInt(split[i]);
		}
		ListNode head = new ListNode(vals[0]);
		Leedcode24 lc=new Leedcode24();
		for(int i=1;i<vals.length;i++) {
			lc.addList(vals[i], head);
		}
		ListNode swapPairs = lc.swapPairs(head);
		lc.selectList(swapPairs);
	}
	/*
	 * 方法一:非递归解法
	 */
	public ListNode swapPairs(ListNode head) {
		//由于题目中说明不能单纯的改变节点内部的值，因此新建了一个链表来保存交换后的链表
		ListNode pre=new ListNode(0);
		//pre的位置相当于只是一个指针，它指向了具体的值
		pre.next=head;
		//临时存储链表
		ListNode temp=pre;
		/*
		 * while循环的条件之所以是这两个，原因是：交换链表只交换偶数个数的节点，若链表总节点数为奇数，
		 * 则只交换前偶数个节点，最后一个奇数节点就不用交换了。这样可以避免遍历链表，判断链表中节点个数。
		 * 提高了效率。
		 */
		while(temp.next!=null && temp.next.next!=null) {
			//start和end用来保存需要交换的两个节点
			ListNode start=temp.next;
			ListNode end=temp.next.next;
			//链表开头的指针指向两个需要交换节点的第二个节点，使之变为新链表中两个交换节点的第一个节点
			temp.next=end;
			//保存需要交换节点的第二个节点的下一个节点为原链表的第三个节点（保存第三个节点）
			start.next=end.next;
			//让需要交换节点的第二个节点的的下一个节点指向第一个节点，完成相邻节点的交换
			end.next=start;
			//为下一次循环设置初始条件
			temp=start;
		}
		//由于第一个结点为没有值的指针，因此交换后的链表为pre.next开始
		return pre.next;
    }
	/*
	 * 方法二:递归解法
	 */
	public ListNode swapPairs1(ListNode head) {
		//当head=null表示节点总数为偶数；若head.next=null表示节点总数为奇数
		if(head==null || head.next==null) {
			return head;
		}
		//记录第二个节点
		ListNode Next=head.next;
		//交换节点后，之前的第一个结点的下一个节点就是在此交换的节点
		head.next=swapPairs1(Next.next);
		//第二个节点的下一个节点为第一个节点
		Next.next=head;
		//交换后，之前的第二个结点为结果的第一个节点
		return Next;
	}
	//单链表添加节点
	public void addList(int val,ListNode head) {
		//临时节点，存储值
		ListNode node = new ListNode(val);
		ListNode temp=head;
		//遍历到最后一个节点
		while(temp.next!=null) {
			temp=temp.next;
		}
		//最后一个节点的下一个节点为临时节点
		temp.next=node;
		//保存增加后的链表
		head=temp;
	}
	//遍历单链表
	public void selectList(ListNode node) {
		while(true) {
			if(node!=null) {
				System.out.print(node.val+"->");
				node=node.next;
			}
			else
				break;
		}
		System.out.print("NULL");
	}
}
```
